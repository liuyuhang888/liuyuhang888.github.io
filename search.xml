<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java基础-集合框架(1)]]></title>
    <url>%2F2019%2F07%2F26%2Fjava%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2Fjava%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[集合简介java中集合是开发中必不可少的常用利器，而在很多面试过程中，集合框架的内部实现原理也是面试中的重点。我们先看一下集合框架的框架结构图，熟悉一下基本的脉络。下面这张张图是我从网上博客摘取的，在此谢谢你精心的绘制。说明一下颜色含义：黄色：代表接口 绿色：代表抽象接口 蓝色：代表实现类 java中集合框架的总图这是两个集合框架接口的总体图分为两个集合接口，分别是Collection接口，和map接口，collection集合是单列集合，而map集合是双列集合，下面我们将详细的从简单的功能功能学习到它的底层实现原理的探索。 Collection集合接口说起存储数据，我们第一个想到的便是使用变量，数组，但是数组有一定的局限性，它一被创建下来，大小就是固定的了，而集合可以根据需要，自动进行增长。数组只能存储固定的一种类型，而集合却可以存储任意类型。种种的优点让我们选择了集合。 集合框架的出现集合框架在jdk1.1时，只有vector一种集合 1.5后出现了集合框架。 集合的实现接口以及子实现类集合的顶层接口：Collection&lt;E&gt;下面主要的三个接口分别是list set Queue list列表是有序，有下标的，可重复的 除linkhashset之外 set集合是无序的，没有下标，不可重复list的主要实现类是：ArrayList LinkedList vector ArrayList的底层是通过数组实现的LinkedList底层是通过链表实现的vector的底层也是通过数组实现 其中和ArrayList相比 线程的安全性不同，vector是线程安全的,在vector的大多数方法都使用synchronized关键字修饰，arrayList是线程不安全的（可以通过Collections.synchronizedList（）实现线程安全） 性能上的差别，由于vector的方法都有同步锁，在方法执行时需要加锁、解锁，所以在执行过程中效率会低于ArrayList，另外，性能上的差别还体现在底层的Object数组上。 默认都是创建容量为10的数组,但ArrayList自动扩容为原来的1.5倍，vector则扩容为原来的两倍123456789101112131415161718192021//扩容，传入最小容量，跟 ArrayList.grow(int) 很相似，只是扩大量不同 private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //如果增长量 capacityIncrement 不大于 0 ，就扩容 2 倍 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 扩容操作在添加元素时触发。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-面向对象]]></title>
    <url>%2F2019%2F07%2F26%2Fjava%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2Fjava%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Java面向对象概述和三大特性 Java 是面向对象的高级编程语言，类和对象是 Java 程序的构成核心。围绕着 Java 类和 Java 对象，有三大基本特性：封装是 Java 类的编写规范、继承是类与类之间联系的一种形式、而多态为系统组件或模块之间解耦提供了解决方案。 本文主要围绕这三大特性介绍一下 Java 面向对象、组件解耦的核心思想。1、面向对象思想 面向对象编程是当今主流的程序设计思想，已经取代了过程化程序开发技术，Java 是完全面向对象编程语言，所以必须熟悉面向对象才能够编写 Java 程序。 面向对象的程序核心是由对象组成的，每个对象包含着对用户公开的特定功能和隐藏的实现部分。程序中的很多对象来自 JDK 标准库，而更多的类需要我们程序员自定义。 从理论上讲，只要对象能够实现业务功能，其具体的实现细节不必特别关心。 面向对象有以下特点： （1）面向对象是一种常见的思想，比较符合人们的思考习惯； （2）面向对象可以将复杂的业务逻辑简单化，增强代码复用性； （3）面向对象具有抽象、封装、继承、多态等特性。 面向对象的编程语言主要有：C++、Java、C#等。2、类和对象的关系 类： 对某类事物的普遍一致性特征、功能的抽象、描述和封装，是构造对象的模版或蓝图，用 Java 编写的代码都会在某些类的内部。类之间主要有：依赖、聚合、继承等关系。 对象： 使用 new 关键字或反射技术创建的某个类的实例。同一个类的所有对象，都具有相似的数据（比如人的年龄、性别）和行为（比如人的吃饭、睡觉），但是每个对象都保存着自己独特的状态，对象状态会随着程序的运行而发生改变，需要注意状态的变化必须通过调用方法来改变，这就是封装的基本原则。3、封装思想 核心思想就是“隐藏细节”、“数据安全”：将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。 具体的实现方式就是： 使用 private 修饰符把成员变量设置为私有，防止外部程序直接随意调用或修改成员变量，然后对外提供 public 的 set 和 get 方法按照开发者的意愿（可以编写一些业务逻辑代码，虽然很少这样做）设置和获取成员变量的值。 也可以把只在本类内部使用的方法使用 private，这就是封装的思想，是面向对象最基本的开发规范之一。 在此，我们有必要说一下 Java 的访问权限修饰关键字。Java 中主要有 private、protected、public 和 默认访问权限 四种： public 修饰符，具有最大的访问权限，可以访问任何一个在 CLASSPATH 下的类、接口、异常等。 protected 修饰符，主要作用就是用来保护子类，子类可以访问这些成员变量和方法，其余类不可以。 default 修饰符，主要是本包的类可以访问。 private 修饰符，访问权限仅限于本类内部，在实际开发过程中，大多数的成员变量和方法都是使用 private 修饰的。 Java 的访问控制是停留在编译层的，只在编译时进行访问权限检查，不会在类文件中留下痕迹。 通过反射机制，还是可以访问类的私有成员的。 在实际的开发过程中，这样的封装方式已经成了 Java Bean 代码编写的规范。现在主流的框架在使用反射技术为对象赋值、取值时使用的都是 set 和 get 方法，而不是直接操作字段的值。 4、继承和类实例化过程 （1）在多个不同的类中抽取出共性的数据和逻辑，对这些共性的内容进行封装一个新的类即父类（也叫做超类或基类），让之前的类来继承这个类，那些共性的内容在子类中就不必重复定义，比如 BaseDAO、BaseAction 等。 （2）Java 的继承机制是单继承，即一个类只能有一个直接父类。 （3）如果子类和父类有同名成员变量和方法，子类可以使用 super 关键字调用父类的成员变量和方法，上述使用方式前提是成员在子类可见。 （4）在调用子类构造方法时，会隐式的调用父类的构造方法 super()。如果父类没有无参构造方法，为了避免编译错误，需要在子类构造方法中显式的调用父类的含参构造方法。 （5）子类创建时调用父类构造方法：子类需要使用父类的成员变量和方法，所以就要调用父类构造方法来初始化，之后再进行子类成员变量和方法的初始化。因此，构造方法是无法覆盖的。 （6）当子类需要扩展父类的某个方法时，可以覆盖父类方法，但是子类方法访问权限必须大于或等于父类权限。 （7）继承提高了程序的复用性、扩展性，也是 Java 语言多态特征的前提。 （8）在实际开发、程序设计过程中，并非先有的父类，而是先有了子类中通用的数据和逻辑，然后再抽取封装出来的父类。 我们简单了解下类的实例化过程 （1）JVM 读取指定 classpath 路径下的 class 文件，加载到内存，如果有直接父类，也会加载父类； （2）堆内存分配空间； （3）执行父类、子类静态代码块； （4）对象属性进行默认初始化； （5）调用构造方法； （6）在构造方法中，先调用父类构造方法初始化父类数据； （7）初始化父类数据后，显示初始化，执行子类的构造代码块； （8）再进行子类构造方法的特定初始化； （9）初始化完毕后，将地址赋值给引用 为了说明上面的内容，我们来编写一个简单的例子，实际意义并不大，只是为了演示类继承实例化的过程。 5、多态、反射和组件解耦 多态指允许不同类的对象对同一“消息”做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。可以用于消除类型之间的耦合关系，Spring 的核心就是多态和面向接口编程。 （1）Java 中可以使用父类、接口变量引用子类、实现类对象； （2）在这个过程中，会对子类、实现类对象做自动类型提升，其特有功能就无法访问了，如果需要使用，可以做强制类型转换。 Java 的反射技术和多态特性是框架开发、组件解耦的核心，在这方面，Spring 的 IOC 和 DI 为我们提供了一个极好的学习范例，Spring 的 IOC 使用反射技术创建、管理对象，DI 使用多态技术为组件注入依赖对象。 在没有学习 Spring 之前，简单的解决方案是使用一个 .properties 文件保存程序中使用的接口、实现类类型键值信息，然后在程序中使用一个全局 Properties 对象保存这些信息，并且使用反射技术把这些实现类初始化、提供一个静态的方法获取指定接口的实现类对象，在组件中就可以使用依赖对象的键获取需要的对象。 这样的方案带来的好处就是：当我们需要修改某个组件的实现方式时，比如把之前 JDBC 的 DAO 实现改为 Hibernate 实现，只要把这些新的实现类放到 classpath 下，把 .properties 文件对应接口的实现类类型改成新的 Hibernate 实现类，而不需要修改依赖组件的代码。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F07%2F24%2Fjava%E5%9F%BA%E7%A1%80%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java的特性 1.简单性Java看起来设计得很像C++，但是为了使语言小和容易熟悉，设计者们把C++语言中许多可用的特征去掉了，这些特征是一般程序员很少使用的。例如，Java不支持go to语句，代之以提供break和continue语句以及异常处理。Java还剔除了C++的操作符过载（overload）和多继承特征，并且不使用主文件，免去了预处理程序。因为Java没有结构，数组和串都是对象，所以不需要指针。Java能够自动处理对象的引用和间接引用，实现自动的无用单元收集，使用户不必为存储管理问题烦恼，能更多的时间和精力花在研发上。 2.面向对象Java是一个面向对象的语言。对程序员来说，这意味着要注意应中的数据和操纵数据的方法（method），而不是严格地用过程来思考。在一个面向对象的系统中，类（class）是数据和操作数据的方法的集合。数据和方法一起描述对象（object）的状态和行为。每一对象是其状态和行为的封装。类是按一定体系和层次安排的，使得子类可以从超类继承行为。在这个类层次体系中有一个根类，它是具有一般行为的类。Java程序是用类来组织的。Java还包括一个类的扩展集合，分别组成各种程序包（Package），用户可以在自己的程序中使用。例如，Java提供产生图形用户接口部件的类（java.awt包），这里awt是抽象窗口工具集（abstract windowing toolkit）的缩写，处理输入输出的类（java.io包）和支持网络功能的类（java.net包）。 3.分布性Java设计成支持在网络上应用，它是分布式语言。Java既支持各种层次的网络连接，又以Socket类支持可靠的流（stream）网络连接，所以用户可以产生分布式的客户机和服务器。网络变成软件应用的分布运载工具。Java程序只要编写一次，就可到处运行。 4.编译和解释性Java编译程序生成字节码（byte-code），而不是通常的机器码。Java字节码提供对体系结构中性的目标文件格式，代码设计成可有效地传送程序到多个平台。Java程序可以在任何实现了Java解释程序和运行系统（run-time system）的系统上运行。在一个解释性的环境中，程序开发的标准“链接”阶段大大消失了。如果说Java还有一个链接阶段，它只是把新类装进环境的过程，它是增量式的、轻量级的过程。因此，Java支持快速原型和容易试验，它将导致快速程序开发。这是一个与传统的、耗时的“编译、链接和测试”形成鲜明对比的精巧的开发过程。 5.稳健性Java原来是用作编写消费类家用电子产品软件的语言，所以它是被设计成写高可靠和稳健软件的。Java消除了某些编程错误，使得用它写可靠软件相当容易。Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。可靠性方面最重要的增强之一是Java的存储模型。Java不支持指针，它消除重写存储和讹误数据的可能性。类似地，Java自动的“无用单元收集”预防存储漏泄和其它有关动态存储分配和解除分配的有害错误。Java解释程序也执行许多运行时的检查，诸如验证所有数组和串访问是否在界限之内。异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用try/catch/finally语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。 6.安全性Java的存储分配模型是它防御恶意代码的主要方法之一。Java没有指针，所以程序员不能得到隐蔽起来的内幕和伪造指针去指向存储器。更重要的是，Java编译程序不处理存储安排决策，所以程序员不能通过查看声明去猜测类的实际存储安排。编译的Java代码中的存储引用在运行时由Java解释程序决定实际存储地址。Java运行系统使用字节码验证过程来保证装载到网络上的代码不违背任何Java语言限制。这个安全机制部分包括类如何从网上装载。例如，装载的类是放在分开的名字空间而不是局部类，预防恶意的小应用程序用它自己的版本来代替标准Java类。 7.可移植性Java使得语言声明不依赖于实现的方面。例如，Java显式说明每个基本数据类型的大小和它的运算行为（这些数据类型由Java语法描述）。Java环境本身对新的硬件平台和操作系统是可移植的。Java编译程序也用Java编写，而Java运行系统用ANSIC语言编写。 8.高性能Java是一种先编译后解释的语言，所以它不如全编译性语言快。但是有些情况下性能是很要紧的，为了支持这些情况，Java设计者制作了“及时”编译程序，它能在运行时把Java字节码翻译成特定CPU（中央处理器）的机器代码，也就是实现全编译了。Java字节码格式设计时考虑到这些“及时”编译程序的需要，所以生成机器代码的过程相当简单，它能产生相当好的代码。 9.多线索性Java是多线索语言，它提供支持多线索的执行（也称为轻便过程），能处理不同任务，使具有线索的程序设计很容易。Java的lang包提供一个Thread类，它支持开始线索、运行线索、停止线索和检查线索状态的方法。 Java的线索支持也包括一组同步原语。这些原语是基于监督程序和条件变量风范，由C.A.R.Haore开发的广泛使用的同步化方案。用关键词synchronized，程序员可以说明某些方法在一个类中不能并发地运行。这些方法在监督程序控制之下，确保变量维持在一个一致的状态。 10.动态性Java语言设计成适应于变化的环境，它是一个动态的语言。例如，Java中的类是根据需要载入的，甚至有些是通过网络获取的。java的基本数据类型 byte 比特 1个字节 short 短整型 2个字节 int 整型 4个字节 long 长整型 8个字节 char 字符型 1个字节（根据编码规则） float 单精度浮点型 4个字节 double 双精度浮点型 8个字节 boolean 布尔型 1个字节java的引用数据类型 object 对象类型 [] 数组类型运算符基本运算符 和C语言基本相同（加减乘除取余）逻辑运算符 与运算 或运算 非运算 （短路）三目运算符 表达式1 ? 表达式2 : 表达式3移位运算符 &lt;&lt; &gt;&gt;左移 又移 流程控制 if 选择分支 if else 多条件分支 switch case 多条件分支 （注意没有break会向下穿透） while 循环 for 循环]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F23%2Fhello-world%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试页</category>
      </categories>
  </entry>
</search>
