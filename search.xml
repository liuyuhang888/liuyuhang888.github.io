<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybatis框架的学习笔记]]></title>
    <url>%2F2019%2F09%2F17%2Fmybatis%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[简介MyBatis是一个Java持久化框架，它通过XML描述符或注解把对象与存储过程或SQL语句关联起来。MyBatis是在Apache许可证 2.0下分发的自由软件，是iBATIS 3.0的分支版本。其维护团队也包含iBATIS的初创成员 —–维基百科 在曾经的开发学习中，我们多次要自己频繁的写JDBC代码获取连接，或者使用连接池来获取数据源。而mybatis为我们提供了一体化的解决方案，使我们只需要定义并声明接口，写上相应的sql语句，即可我们创建代理对象来操作数据库。 与hebernate对比hebernate是一个自动化的一体式框架Mybatis相对于它的优点在于,hebernate复杂而庞大，学习成本高，灵活性较低，不是将sql交给开发人员来填写，若需要进行sql优化是。费时费力。 使用基本流程1.读取mybatis配置文件：mybatis-config.xml 为myBatis的全局配置文件，配置运行环境等信息，例如数据库的连接信息。（后期在SSM整合时交给Spring来管理。配置SqlseesionFactoryBean对象）。 2.加载映射配置文件。映射文件即在mybatis-config.xml中加载，形成多个配置文件。注意：映射文件所在的包路径要和mapper（Dao）类中的路径相同。 3.构建会话工厂，这里mybatis使用了构建者模式。需要SqlSessionFactoryBullder来创建工厂。 4.使用工厂来创建SqlSession。 5.通过SqlSession来创建Mapper的映射对象，调用方法进行查询。 mybatis基于XML的配置主配置文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default="mysql"&gt; &lt;!-- 配置mysql环境 --&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务类型 --&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type="POOLED"&gt; &lt;!-- 配置 连接池的基本信息 --&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy_mybatis"&gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 制定映射配置文件的位置 --&gt; &lt;mappers&gt; &lt;mapper resource="com/liuyuhang/dao/IUserDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 映射配置文件1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.liuyuhang.dao.IUserDao"&gt; &lt;select id="findAll" resultType="com.liuyuhang.domain.User"&gt; select * from user; &lt;/select&gt; &lt;insert id="saveUser" parameterType="com.liuyuhang.domain.User"&gt; &lt;!--配置插入后获取插入数据的id--&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt; select last_insert_id(); &lt;/selectKey&gt; INSERT INTO USER(username,address,sex,birthday) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;); &lt;/insert&gt; &lt;update id="updataUser" parameterType="com.liuyuhang.domain.User"&gt; update user set username=#&#123;username&#125;,address=#&#123;address&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125; where id=#&#123;id&#125;; &lt;/update&gt; &lt;delete id="deleteUser" parameterType="int"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;select id="findUserById" parameterType="int" resultType="com.liuyuhang.domain.User"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;select id="findUserByName" parameterType="String" resultType="com.liuyuhang.domain.User"&gt; select * from user where username like "%"#&#123;name&#125;"%" &lt;!-- 使用的是预处理的方式 ？ 占位符 安全--&gt; &lt;!-- select * from user where username like '%$&#123;value&#125;%' --&gt; &lt;!-- 使用的是拼接字符串的方式 不安全--&gt; &lt;/select&gt; &lt;select id="findTotal" resultType="int"&gt; select count(id) from user &lt;/select&gt; &lt;select id="findqueryVoByName" parameterType="com.liuyuhang.domain.QueryVo" resultType="com.liuyuhang.domain.User"&gt; select * from user where username like "%"#&#123;user.username&#125;"%" &lt;/select&gt;&lt;/mapper&gt; mybatis的核心配置通过刚才的配置示例，我们可以看到核心配置文件所拥有的几个功能。配置数据库环境，配置事物，配置连接池，注册驱动连接数据库，配置插件。 另外，mybatis可以自动配置别名。配置后在映射配置文件中就不必写全限定类名。别名的配置方法有两种:第一种： 1234&lt;!--为实体类com.demo.dao.User配置一个别名User--&gt;&lt;typeAliases&gt; &lt;typeAlias type="com.demo.dao.User" alias="User"/&gt;&lt;/typeAliases&gt; 第二种 1234567&lt;!-- 为com.demo.dao包下的所有实体类配置别名，MyBatis默认的设置别名的方式就是去除类所在的包后的简单的类名,比如com.demo.dao.User这个实体类的别名就会被设置成User --&gt;&lt;typeAliases&gt; &lt;package name="com.demo.dao"/&gt;&lt;/typeAliases&gt; 在spring整合后配置 123456789&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="databaseIdProvider" ref="databaseIdProvider" /&gt; &lt;property name="mapperLocations" value="classpath*:/mapper/*/oracle/*.xml" /&gt; &lt;!-- 给映射的类配置别名 --&gt; &lt;!-- 默认的别名是model类的首字母小写 --&gt; &lt;!-- 如：StaffDeploy实体类。别名为：staffDeploy --&gt; &lt;property name="typeAliasesPackage" value="com.tongdatech.demo.domain;com.tongdatech.sys.domain;com.tongdatech.hr.domain" /&gt; mybatis的映射配置mybatis最强大的地方就在于映射器，由一个接口加上XML文件组成。另外，映射器也可以由注解组成。映射配置文件的常用元素：元素名称 | 描述 | 备注 |-|-|-select | 查询语句，最常用，最复杂的元素之一 | 可以自定义参数，返回结果集等|insert|插入语句|执行后返回一个整数，代表插入的行数|update|更新语句|执行后返回一个整数，代表更新的行数|delete|删除语句|执行后返回一个整数，代表删除的行数|sql|定义一部分sql，在多个位置引用|例如一张表，列名一次定义，在多个地方使用|resultMap|用来描述从数据库结果集中来加载对象|提供映射规则，在Bean对中有映射关系时或数据库名与列名不同时常用|…未完待续]]></content>
      <categories>
        <category>javaEE</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-集合框架（3）]]></title>
    <url>%2F2019%2F07%2F29%2Fjava%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[java基础-集合框架（2）]]></title>
    <url>%2F2019%2F07%2F28%2Fjava%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[map集合HashMap简介不同版本的 JDK 实现 HashMap 的原理有所不同：JDK 1.6, JDK 1.7 HashMap 采用位桶 + 链表实现。JDK 1.8 HashMap 采用位桶 + 链表 + 红黑树实现。（当链表长度超过阈值 “8” 时，将链表转换为红黑树）我们先介绍位桶 + 链表这一种形式。简单说明HashMap 的每一个元素，都是链表的一个节点（entry）。新增一个元素时，会先计算 key 的 hash 值，找到存入数组的位置。如果该位置已经有节点（链表头），则存入该节点的最后一个位置（链表尾）。所以 HashMap 就是一个数组（bucket），数组上每一个元素都是一个节点（节点和所有下一个节点组成一个链表）或者为空，显然同一个链表上的节点 hash 值都一样。HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 HashMap和map的关系 1234567891011// 默认构造函数。HashMap()// 指定“容量大小”的构造函数HashMap(int capacity)// 指定“容量大小”和“加载因子”的构造函数HashMap(int capacity, float loadFactor)// 包含“子Map”的构造函数HashMap(Map&lt;? extends K, ? extends V&gt; map) hashmap的api12345678910111213void clear()Object clone()boolean containsKey(Object key)boolean containsValue(Object value)Set&lt;Entry&lt;K, V&gt;&gt; entrySet()V get(Object key)boolean isEmpty()Set&lt;K&gt; keySet()V put(K key, V value)void putAll(Map&lt;? extends K, ? extends V&gt; map)V remove(Object key)int size()Collection&lt;V&gt; values() map集合的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759package java.util;import java.io.*;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; // 默认的初始容量是16，必须是2的幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的大小，它是HashMap保存的键值对的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 默认构造函数。 public HashMap() &#123; // 设置“加载因子” this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); &#125; // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); &#125; static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; // 返回索引值 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; // 获取key对应的value public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置！ private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; // HashMap是否包含key public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回“键为key”的键值对 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; // 将“key-value”添加到HashMap中 public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null; &#125; // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 这里的完全不会被执行到! modCount++; addEntry(0, null, value, 0); return null; &#125; // 创建HashMap对应的“添加方法”， // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap // 而put()是对外提供的往HashMap中添加元素的方法。 private void putForCreate(K key, V value) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; e.value = value; return; &#125; &#125; // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中 createEntry(hash, key, value, i); &#125; // 将“m”中的全部元素都添加到HashMap中。 // 该方法被内部的构造HashMap的方法所调用。 private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123; // 利用迭代器将元素逐个添加到HashMap中 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); putForCreate(e.getKey(), e.getValue()); &#125; &#125; // 重新调整HashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; // 将"m"的全部元素都添加到HashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); &#125; &#125; // 删除“键为key”元素 public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); &#125; // 删除“键为key”的元素 final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 删除“键值对” final Entry&lt;K,V&gt; removeMapping(Object o) &#123; if (!(o instanceof Map.Entry)) return null; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; Object key = entry.getKey(); int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (e.hash == hash &amp;&amp; e.equals(entry)) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 清空HashMap，将所有的元素设为null public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; &#125; // 是否包含“值为value”的元素 public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; // 是否包含null值 private boolean containsNullValue() &#123; Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; &#125; // 克隆一个HashMap，并返回Object对象 public Object clone() &#123; HashMap&lt;K,V&gt; result = null; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // assert false; &#125; result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; &#125; // Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); &#125; // 创建Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 // 它和addEntry的区别是： // (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。 // 例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素； // put()是通过addEntry()新增Entry的。 // 在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”； // 因此，需要调用addEntry() // (02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。 // 例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中； // 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中 // 的全部元素添加到HashMap中，都不会超过HashMap的阈值”。 // 此时，调用createEntry()即可。 void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++; &#125; // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; // 删除当前元素 public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; &#125; // value的迭代器 private final class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125; // key的迭代器 private final class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125; // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // 返回一个“key迭代器” Iterator&lt;K&gt; newKeyIterator() &#123; return new KeyIterator(); &#125; // 返回一个“value迭代器” Iterator&lt;V&gt; newValueIterator() &#123; return new ValueIterator(); &#125; // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; return new EntryIterator(); &#125; // HashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); &#125; // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private final class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return newKeyIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return HashMap.this.removeEntryForKey(o) != null; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); &#125; // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private final class Values extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return newValueIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; return entrySet0(); &#125; // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); &#125; // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return newEntryIterator(); &#125; public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; public int size() &#123; return size; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) &#123; while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; &#125; private static final long serialVersionUID = 362498820763181265L; // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) &#123; K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); &#125; &#125; // 返回“HashMap总的容量” int capacity() &#123; return table.length; &#125; // 返回“HashMap的加载因子” float loadFactor() &#123; return loadFactor; &#125;&#125; 在详细介绍HashMap的代码之前，我们需要了解：HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的。 还需要再补充说明的一点是影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 entry的源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125;&#125; 从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说HashMap是通过拉链法解决哈希冲突的。Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。 hash表解决冲突通常有三种方法 拉链法 开放地址法 再散列法详情引用csdn博主博文 https://blog.csdn.net/qq_32595453/article/details/80660676 TreeMapTreeMap 简介 TreeMap是一个有序的key-value集合，它用红黑树实现TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。TreeMap 实现了Cloneable接口，意味着它能被克隆。TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。 TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。 TreeMap的api1234567891011// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。TreeMap()// 创建的TreeMap包含MapTreeMap(Map&lt;? extends K, ? extends V&gt; copyFrom)// 指定Tree的比较器TreeMap(Comparator&lt;? super K&gt; comparator)// 创建的TreeSet包含copyFromTreeMap(SortedMap&lt;K, ? extends V&gt; copyFrom) 12345678910111213141516171819202122232425262728293031323334Entry&lt;K, V&gt; ceilingEntry(K key)K ceilingKey(K key)void clear()Object clone()Comparator&lt;? super K&gt; comparator()boolean containsKey(Object key)NavigableSet&lt;K&gt; descendingKeySet()NavigableMap&lt;K, V&gt; descendingMap()Set&lt;Entry&lt;K, V&gt;&gt; entrySet()Entry&lt;K, V&gt; firstEntry()K firstKey()Entry&lt;K, V&gt; floorEntry(K key)K floorKey(K key)V get(Object key)NavigableMap&lt;K, V&gt; headMap(K to, boolean inclusive)SortedMap&lt;K, V&gt; headMap(K toExclusive)Entry&lt;K, V&gt; higherEntry(K key)K higherKey(K key)boolean isEmpty()Set&lt;K&gt; keySet()Entry&lt;K, V&gt; lastEntry()K lastKey()Entry&lt;K, V&gt; lowerEntry(K key)K lowerKey(K key)NavigableSet&lt;K&gt; navigableKeySet()Entry&lt;K, V&gt; pollFirstEntry()Entry&lt;K, V&gt; pollLastEntry()V put(K key, V value)V remove(Object key)int size()SortedMap&lt;K, V&gt; subMap(K fromInclusive, K toExclusive)NavigableMap&lt;K, V&gt; subMap(K from, boolean fromInclusive, K to, boolean toInclusive)NavigableMap&lt;K, V&gt; tailMap(K from, boolean inclusive)SortedMap&lt;K, V&gt; tailMap(K fromInclusive) TreeMap与Map的关系如下从图中可以看出：(01) TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。(02) TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。 root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。 红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。 size是红黑数中节点的个数。 TreeMap的原理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050package java.util;public class TreeMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt;implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; // 比较器。用来给TreeMap排序 private final Comparator&lt;? super K&gt; comparator; // TreeMap是红黑树实现的，root是红黑书的根节点 private transient Entry&lt;K,V&gt; root = null; // 红黑树的节点总数 private transient int size = 0; // 记录红黑树的修改次数 private transient int modCount = 0; // 默认构造函数 public TreeMap() &#123; comparator = null; &#125; // 带比较器的构造函数 public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator; &#125; // 带Map的构造函数，Map会成为TreeMap的子集 public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m); &#125; // 带SortedMap的构造函数，SortedMap会成为TreeMap的子集 public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; &#125; public int size() &#123; return size; &#125; // 返回TreeMap中是否包含“键(key)” public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回TreeMap中是否包含"值(value)" public boolean containsValue(Object value) &#123; // getFirstEntry() 是返回红黑树的第一个节点 // successor(e) 是获取节点e的后继节点 for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) if (valEquals(value, e.value)) return true; return false; &#125; // 获取“键(key)”对应的“值(value)” public V get(Object key) &#123; // 获取“键”为key的节点(p) Entry&lt;K,V&gt; p = getEntry(key); // 若节点(p)为null，返回null；否则，返回节点对应的值 return (p==null ? null : p.value); &#125; public Comparator&lt;? super K&gt; comparator() &#123; return comparator; &#125; // 获取第一个节点对应的key public K firstKey() &#123; return key(getFirstEntry()); &#125; // 获取最后一个节点对应的key public K lastKey() &#123; return key(getLastEntry()); &#125; // 将map中的全部节点添加到TreeMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; // 获取map的大小 int mapSize = map.size(); // 如果TreeMap的大小是0,且map的大小不是0,且map是已排序的“key-value对” if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) &#123; Comparator c = ((SortedMap)map).comparator(); // 如果TreeMap和map的比较器相等； // 则将map的元素全部拷贝到TreeMap中，然后返回！ if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) &#123; ++modCount; try &#123; buildFromSorted(mapSize, map.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return; &#125; &#125; // 调用AbstractMap中的putAll(); // AbstractMap中的putAll()又会调用到TreeMap的put() super.putAll(map); &#125; // 获取TreeMap中“键”为key的节点 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 若“比较器”为null，则通过getEntryUsingComparator()获取“键”为key的节点 if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的左孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; &#125; return null; &#125; // 获取TreeMap中“键”为key的节点(对应TreeMap的比较器不是null的情况) final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = cpr.compare(k, p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的左孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; &#125; &#125; return null; &#125; // 获取TreeMap中不小于key的最小的节点； // 若不存在(即TreeMap中所有节点的键都比key大)，就返回null final Entry&lt;K,V&gt; getCeilingEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); // 情况一：若“p的key” &gt; key。 // 若 p 存在左孩子，则设 p=“p的左孩子”； // 否则，返回p if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; // 情况二：若“p的key” &lt; key。 &#125; else if (cmp &gt; 0) &#123; // 若 p 存在右孩子，则设 p=“p的右孩子” if (p.right != null) &#123; p = p.right; &#125; else &#123; // 若 p 不存在右孩子，则找出 p 的后继节点，并返回 // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。 // 理解这一点的核心是，getCeilingEntry是从root开始遍历的。 // 若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。 // 能理解上面所说的，那么就很容易明白，为什么“p的后继节点”又2种可能性了。 Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; // 情况三：若“p的key” = key。 &#125; else return p; &#125; return null; &#125; // 获取TreeMap中不大于key的最大的节点； // 若不存在(即TreeMap中所有节点的键都比key小)，就返回null // getFloorEntry的原理和getCeilingEntry类似，这里不再多说。 final Entry&lt;K,V&gt; getFloorEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else if (cmp &lt; 0) &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; else return p; &#125; return null; &#125; // 获取TreeMap中大于key的最小的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getHigherEntry进行理解。 final Entry&lt;K,V&gt; getHigherEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; &#125; else &#123; if (p.right != null) &#123; p = p.right; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; // 获取TreeMap中小于key的最大的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getLowerEntry进行理解。 final Entry&lt;K,V&gt; getLowerEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; // 将“key, value”添加到TreeMap中 // 理解TreeMap的前提是掌握“红黑树”。 // 若理解“红黑树中添加节点”的算法，则很容易理解put。 public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; // 若红黑树为空，则插入根节点 if (t == null) &#123; // TBD: // 5045147: (coll) Adding null to an empty TreeSet should // throw NullPointerException // // compare(key, key); // type check root = new Entry&lt;K,V&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; // 在二叉树(红黑树是特殊的二叉树)中，找到(key, value)的插入位置。 // 红黑树是以key来进行排序的，所以这里以key来进行查找。 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 新建红黑树的节点(e) Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; // 红黑树插入节点后，不再是一颗红黑树； // 这里通过fixAfterInsertion的处理，来恢复红黑树的特性。 fixAfterInsertion(e); size++; modCount++; return null; &#125; // 删除TreeMap中的键为key的节点，并返回节点的值 public V remove(Object key) &#123; // 找到键为key的节点 Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; // 保存节点的值 V oldValue = p.value; // 删除节点 deleteEntry(p); return oldValue; &#125; // 清空红黑树 public void clear() &#123; modCount++; size = 0; root = null; &#125; // 克隆一个TreeMap，并返回Object对象 public Object clone() &#123; TreeMap&lt;K,V&gt; clone = null; try &#123; clone = (TreeMap&lt;K,V&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // Put clone into "virgin" state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try &#123; clone.buildFromSorted(size, entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return clone; &#125; // 获取第一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(getFirstEntry()); &#125; // 获取最后一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(getLastEntry()); &#125; // 获取第一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; // 获取第一个节点 Entry&lt;K,V&gt; p = getFirstEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除第一个节点 if (p != null) deleteEntry(p); return result; &#125; // 获取最后一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollLastEntry() &#123; // 获取最后一个节点 Entry&lt;K,V&gt; p = getLastEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除最后一个节点 if (p != null) deleteEntry(p); return result; &#125; // 返回小于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(getLowerEntry(key)); &#125; // 返回小于key的最大的键值对所对应的KEY，没有的话返回null public K lowerKey(K key) &#123; return keyOrNull(getLowerEntry(key)); &#125; // 返回不大于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(getFloorEntry(key)); &#125; // 返回不大于key的最大的键值对所对应的KEY，没有的话返回null public K floorKey(K key) &#123; return keyOrNull(getFloorEntry(key)); &#125; // 返回不小于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(getCeilingEntry(key)); &#125; // 返回不小于key的最小的键值对所对应的KEY，没有的话返回null public K ceilingKey(K key) &#123; return keyOrNull(getCeilingEntry(key)); &#125; // 返回大于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(getHigherEntry(key)); &#125; // 返回大于key的最小的键值对所对应的KEY，没有的话返回null public K higherKey(K key) &#123; return keyOrNull(getHigherEntry(key)); &#125; // TreeMap的红黑树节点对应的集合 private transient EntrySet entrySet = null; // KeySet为KeySet导航类 private transient KeySet&lt;K&gt; navigableKeySet = null; // descendingMap为键值对的倒序“映射” private transient NavigableMap&lt;K,V&gt; descendingMap = null; // 返回TreeMap的“键的集合” public Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 获取“可导航”的Key的集合 // 实际上是返回KeySet类的对象。 public NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nks = navigableKeySet; return (nks != null) ? nks : (navigableKeySet = new KeySet(this)); &#125; // 返回“TreeMap的值对应的集合” public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values()); &#125; // 获取TreeMap的Entry的集合，实际上是返回EntrySet类的对象。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet()); &#125; // 获取TreeMap的降序Map // 实际上是返回DescendingSubMap类的对象 public NavigableMap&lt;K, V&gt; descendingMap() &#123; NavigableMap&lt;K, V&gt; km = descendingMap; return (km != null) ? km : (descendingMap = new DescendingSubMap(this, true, null, true, true, null, true)); &#125; // 获取TreeMap的子Map // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; return new AscendingSubMap(this, false, fromKey, fromInclusive, false, toKey, toInclusive); &#125; // 获取“Map的头部” // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; return new AscendingSubMap(this, true, null, true, false, toKey, inclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) &#123; return new AscendingSubMap(this, false, fromKey, inclusive, true, null, true); &#125; // 获取“子Map”。 // 范围是从fromKey(包括) 到 toKey(不包括) public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey(不包括) public SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey(包括) 到 最后一个节点 public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // ”TreeMap的值的集合“对应的类，它集成于AbstractCollection class Values extends AbstractCollection&lt;V&gt; &#123; // 返回迭代器 public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(getFirstEntry()); &#125; // 返回个数 public int size() &#123; return TreeMap.this.size(); &#125; // "TreeMap的值的集合"中是否包含"对象o" public boolean contains(Object o) &#123; return TreeMap.this.containsValue(o); &#125; // 删除"TreeMap的值的集合"中的"对象o" public boolean remove(Object o) &#123; for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) &#123; if (valEquals(e.getValue(), o)) &#123; deleteEntry(e); return true; &#125; &#125; return false; &#125; // 清空删除"TreeMap的值的集合" public void clear() &#123; TreeMap.this.clear(); &#125; &#125; // EntrySet是“TreeMap的所有键值对组成的集合”， // EntrySet集合的单位是单个“键值对”。 class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(getFirstEntry()); &#125; // EntrySet中是否包含“键值对Object” public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); return p != null &amp;&amp; valEquals(p.getValue(), value); &#125; // 删除EntrySet中的“键值对Object” public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); if (p != null &amp;&amp; valEquals(p.getValue(), value)) &#123; deleteEntry(p); return true; &#125; return false; &#125; // 返回EntrySet中元素个数 public int size() &#123; return TreeMap.this.size(); &#125; // 清空EntrySet public void clear() &#123; TreeMap.this.clear(); &#125; &#125; // 返回“TreeMap的KEY组成的迭代器(顺序)” Iterator&lt;K&gt; keyIterator() &#123; return new KeyIterator(getFirstEntry()); &#125; // 返回“TreeMap的KEY组成的迭代器(逆序)” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingKeyIterator(getLastEntry()); &#125; // KeySet是“TreeMap中所有的KEY组成的集合” // KeySet继承于AbstractSet，而且实现了NavigableSet接口。 static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; &#123; // NavigableMap成员，KeySet是通过NavigableMap实现的 private final NavigableMap&lt;E, Object&gt; m; KeySet(NavigableMap&lt;E,Object&gt; map) &#123; m = map; &#125; // 升序迭代器 public Iterator&lt;E&gt; iterator() &#123; // 若是TreeMap对象，则调用TreeMap的迭代器keyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器keyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).keyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).keyIterator()); &#125; // 降序迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; // 若是TreeMap对象，则调用TreeMap的迭代器descendingKeyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器descendingKeyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).descendingKeyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).descendingKeyIterator()); &#125; public int size() &#123; return m.size(); &#125; public boolean isEmpty() &#123; return m.isEmpty(); &#125; public boolean contains(Object o) &#123; return m.containsKey(o); &#125; public void clear() &#123; m.clear(); &#125; public E lower(E e) &#123; return m.lowerKey(e); &#125; public E floor(E e) &#123; return m.floorKey(e); &#125; public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; public E higher(E e) &#123; return m.higherKey(e); &#125; public E first() &#123; return m.firstKey(); &#125; public E last() &#123; return m.lastKey(); &#125; public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; public E pollFirst() &#123; Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry(); return e == null? null : e.getKey(); &#125; public E pollLast() &#123; Map.Entry&lt;E,Object&gt; e = m.pollLastEntry(); return e == null? null : e.getKey(); &#125; public boolean remove(Object o) &#123; int oldSize = size(); m.remove(o); return size() != oldSize; &#125; public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; public NavigableSet&lt;E&gt; descendingSet() &#123; return new TreeSet(m.descendingMap()); &#125; &#125; // 它是TreeMap中的一个抽象迭代器，实现了一些通用的接口。 abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // 上一次返回元素 Entry&lt;K,V&gt; lastReturned; // 期望的修改次数，用于实现fast-fail机制 int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123; expectedModCount = modCount; lastReturned = null; next = first; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个节点 final Entry&lt;K,V&gt; nextEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; &#125; // 获取上一个节点 final Entry&lt;K,V&gt; prevEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点 public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，'新的当前节点'实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向"新的当前节点"。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; &#125; &#125; // TreeMap的Entry对应的迭代器 final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntryIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // TreeMap的Value对应的迭代器 final class ValueIterator extends PrivateEntryIterator&lt;V&gt; &#123; ValueIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public V next() &#123; return nextEntry().value; &#125; &#125; // reeMap的KEY组成的迭代器(顺序) final class KeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; KeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return nextEntry().key; &#125; &#125; // TreeMap的KEY组成的迭代器(逆序) final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return prevEntry().key; &#125; &#125; // 比较两个对象的大小 final int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2); &#125; // 判断两个对象是否相等 final static boolean valEquals(Object o1, Object o2) &#123; return (o1==null ? o2==null : o1.equals(o2)); &#125; // 返回“Key-Value键值对”的一个简单拷贝(AbstractMap.SimpleImmutableEntry&lt;K,V&gt;对象) // 可用来读取“键值对”的值 static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e); &#125; // 若“键值对”不为null，则返回KEY；否则，返回null static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : e.key; &#125; // 若“键值对”不为null，则返回KEY；否则，抛出异常 static &lt;K&gt; K key(Entry&lt;K,?&gt; e) &#123; if (e==null) throw new NoSuchElementException(); return e.key; &#125; // TreeMap的SubMap，它一个抽象类，实现了公共操作。 // 它包括了"(升序)AscendingSubMap"和"(降序)DescendingSubMap"两个子类。 static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, java.io.Serializable &#123; // TreeMap的拷贝 final TreeMap&lt;K,V&gt; m; // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”； // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记” // fromStart是“表示是否从第一个节点开始计算”， // toEnd是“表示是否计算到最后一个节点 ” final K lo, hi; final boolean fromStart, toEnd; final boolean loInclusive, hiInclusive; // 构造函数 NavigableSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; if (!fromStart &amp;&amp; !toEnd) &#123; if (m.compare(lo, hi) &gt; 0) throw new IllegalArgumentException("fromKey &gt; toKey"); &#125; else &#123; if (!fromStart) // type check m.compare(lo, lo); if (!toEnd) m.compare(hi, hi); &#125; this.m = m; this.fromStart = fromStart; this.lo = lo; this.loInclusive = loInclusive; this.toEnd = toEnd; this.hi = hi; this.hiInclusive = hiInclusive; &#125; // 判断key是否太小 final boolean tooLow(Object key) &#123; // 若该SubMap不包括“起始节点”， // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内” // 则判断key太小。其余情况都不是太小！ if (!fromStart) &#123; int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; &#125; return false; &#125; // 判断key是否太大 final boolean tooHigh(Object key) &#123; // 若该SubMap不包括“结束节点”， // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内” // 则判断key太大。其余情况都不是太大！ if (!toEnd) &#123; int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; &#125; return false; &#125; // 判断key是否在“lo和hi”开区间范围内 final boolean inRange(Object key) &#123; return !tooLow(key) &amp;&amp; !tooHigh(key); &#125; // 判断key是否在封闭区间内 final boolean inClosedRange(Object key) &#123; return (fromStart || m.compare(key, lo) &gt;= 0) &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0); &#125; // 判断key是否在区间内, inclusive是区间开关标志 final boolean inRange(Object key, boolean inclusive) &#123; return inclusive ? inRange(key) : inClosedRange(key); &#125; // 返回最低的Entry final TreeMap.Entry&lt;K,V&gt; absLowest() &#123; // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点 // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry; // 否则，调用getHigherEntry(lo)获取大于lo的最小Entry TreeMap.Entry&lt;K,V&gt; e = (fromStart ? m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo))); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回最高的Entry final TreeMap.Entry&lt;K,V&gt; absHighest() &#123; // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点 // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry; // 否则，调用getLowerEntry(hi)获取大于hi的最大Entry TreeMap.Entry&lt;K,V&gt; e = TreeMap.Entry&lt;K,V&gt; e = (toEnd ? m.getLastEntry() : (hiInclusive ? m.getFloorEntry(hi) : m.getLowerEntry(hi))); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回"大于/等于key的最小的Entry" final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！ if (tooLow(key)) return absLowest(); // 获取“大于/等于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回"大于key的最小的Entry" final TreeMap.Entry&lt;K,V&gt; absHigher(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！ if (tooLow(key)) return absLowest(); // 获取“大于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回"小于/等于key的最大的Entry" final TreeMap.Entry&lt;K,V&gt; absFloor(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！ if (tooHigh(key)) return absHighest(); // 获取"小于/等于key的最大的Entry" TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回"小于key的最大的Entry" final TreeMap.Entry&lt;K,V&gt; absLower(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！ if (tooHigh(key)) return absHighest(); // 获取"小于key的最大的Entry" TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回“大于最大节点中的最小节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absHighFence() &#123; return (toEnd ? null : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi))); &#125; // 返回“小于最小节点中的最大节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absLowFence() &#123; return (fromStart ? null : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo))); &#125; // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法 abstract TreeMap.Entry&lt;K,V&gt; subLowest(); abstract TreeMap.Entry&lt;K,V&gt; subHighest(); abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key); abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key); abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key); abstract TreeMap.Entry&lt;K,V&gt; subLower(K key); // 返回“顺序”的键迭代器 abstract Iterator&lt;K&gt; keyIterator(); // 返回“逆序”的键迭代器 abstract Iterator&lt;K&gt; descendingKeyIterator(); // 返回SubMap是否为空。空的话，返回true，否则返回false public boolean isEmpty() &#123; return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty(); &#125; // 返回SubMap的大小 public int size() &#123; return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size(); &#125; // 返回SubMap是否包含键key public final boolean containsKey(Object key) &#123; return inRange(key) &amp;&amp; m.containsKey(key); &#125; // 将key-value 插入SubMap中 public final V put(K key, V value) &#123; if (!inRange(key)) throw new IllegalArgumentException("key out of range"); return m.put(key, value); &#125; // 获取key对应值 public final V get(Object key) &#123; return !inRange(key)? null : m.get(key); &#125; // 删除key对应的键值对 public final V remove(Object key) &#123; return !inRange(key)? null : m.remove(key); &#125; // 获取“大于/等于key的最小键值对” public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(subCeiling(key)); &#125; // 获取“大于/等于key的最小键” public final K ceilingKey(K key) &#123; return keyOrNull(subCeiling(key)); &#125; // 获取“大于key的最小键值对” public final Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(subHigher(key)); &#125; // 获取“大于key的最小键” public final K higherKey(K key) &#123; return keyOrNull(subHigher(key)); &#125; // 获取“小于/等于key的最大键值对” public final Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(subFloor(key)); &#125; // 获取“小于/等于key的最大键” public final K floorKey(K key) &#123; return keyOrNull(subFloor(key)); &#125; // 获取“小于key的最大键值对” public final Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(subLower(key)); &#125; // 获取“小于key的最大键” public final K lowerKey(K key) &#123; return keyOrNull(subLower(key)); &#125; // 获取"SubMap的第一个键" public final K firstKey() &#123; return key(subLowest()); &#125; // 获取"SubMap的最后一个键" public final K lastKey() &#123; return key(subHighest()); &#125; // 获取"SubMap的第一个键值对" public final Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(subLowest()); &#125; // 获取"SubMap的最后一个键值对" public final Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(subHighest()); &#125; // 返回"SubMap的第一个键值对"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subLowest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // 返回"SubMap的最后一个键值对"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollLastEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subHighest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // Views transient NavigableMap&lt;K,V&gt; descendingMapView = null; transient EntrySetView entrySetView = null; transient KeySet&lt;K&gt; navigableKeySetView = null; // 返回NavigableSet对象，实际上返回的是当前对象的"Key集合"。 public final NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nksv = navigableKeySetView; return (nksv != null) ? nksv : (navigableKeySetView = new TreeMap.KeySet(this)); &#125; // 返回"Key集合"对象 public final Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 返回“逆序”的Key集合 public NavigableSet&lt;K&gt; descendingKeySet() &#123; return descendingMap().navigableKeySet(); &#125; // 排列fromKey(包含) 到 toKey(不包含) 的子map public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey) public final SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点] public final SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // Map的Entry的集合 abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; private transient int size = -1, sizeModCount; // 获取EntrySet的大小 public int size() &#123; // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小 if (fromStart &amp;&amp; toEnd) return m.size(); // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素 if (size == -1 || sizeModCount != m.modCount) &#123; sizeModCount = m.modCount; size = 0; Iterator i = iterator(); while (i.hasNext()) &#123; size++; i.next(); &#125; &#125; return size; &#125; // 判断EntrySetView是否为空 public boolean isEmpty() &#123; TreeMap.Entry&lt;K,V&gt; n = absLowest(); return n == null || tooHigh(n.key); &#125; // 判断EntrySetView是否包含Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry node = m.getEntry(key); return node != null &amp;&amp; valEquals(node.getValue(), entry.getValue()); &#125; // 从EntrySetView中删除Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key); if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue()))&#123; m.deleteEntry(node); return true; &#125; return false; &#125; &#125; // SubMap的迭代器 abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 上一次被返回的Entry TreeMap.Entry&lt;K,V&gt; lastReturned; // 指向下一个Entry TreeMap.Entry&lt;K,V&gt; next; // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义 final K fenceKey; int expectedModCount; // 构造函数 SubMapIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; // 每创建一个SubMapIterator时，保存修改次数 // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。 // 这就是所说的fast-fail机制的原理！ expectedModCount = m.modCount; lastReturned = null; next = first; fenceKey = fence == null ? null : fence.key; &#125; // 是否存在下一个Entry public final boolean hasNext() &#123; return next != null &amp;&amp; next.key != fenceKey; &#125; // 返回下一个Entry final TreeMap.Entry&lt;K,V&gt; nextEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的后继节点 next = successor(e); lastReturned = e; return e; &#125; // 返回上一个Entry final TreeMap.Entry&lt;K,V&gt; prevEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的前继节点 next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点(用于“升序的SubMap”)。 // 删除之后，可以继续升序遍历；红黑树特性没变。 final void removeAscending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，'新的当前节点'实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向"新的当前节点"。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; // 删除当前节点(用于“降序的SubMap”)。 // 删除之后，可以继续降序遍历；红黑树特性没变。 final void removeDescending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; &#125; // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public K next() &#123; return nextEntry().key; &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public Map.Entry&lt;K,V&gt; next() &#123; return prevEntry(); &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public K next() &#123; return prevEntry().key; &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; &#125; // 升序的SubMap，继承于NavigableSubMap static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866124060L; // 构造函数 AscendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 比较器 public Comparator&lt;? super K&gt; comparator() &#123; return m.comparator(); &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException("fromKey out of range"); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException("toKey out of range"); return new AscendingSubMap(m, false, fromKey, fromInclusive, false, toKey, toInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException("toKey out of range"); return new AscendingSubMap(m, fromStart, lo, loInclusive, false, toKey, inclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException("fromKey out of range"); return new AscendingSubMap(m, false, fromKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new DescendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // “升序EntrySet集合”类 // 实现了iterator() final class AscendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new SubMapEntryIterator(absLowest(), absHighFence()); &#125; &#125; // 返回“升序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new AscendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absHigher(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absLower(key); &#125; &#125; // 降序的SubMap，继承于NavigableSubMap // 相比于升序SubMap，它的实现机制是将“SubMap的比较器反转”！ static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866120460L; DescendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 反转的比较器：是将原始比较器反转得到的。 private final Comparator&lt;? super K&gt; reverseComparator = Collections.reverseOrder(m.comparator); // 获取反转比较器 public Comparator&lt;? super K&gt; comparator() &#123; return reverseComparator; &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException("fromKey out of range"); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException("toKey out of range"); return new DescendingSubMap(m, false, toKey, toInclusive, false, fromKey, fromInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException("toKey out of range"); return new DescendingSubMap(m, false, toKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException("fromKey out of range"); return new DescendingSubMap(m, fromStart, lo, loInclusive, false, fromKey, inclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new AscendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // “降序EntrySet集合”类 // 实现了iterator() final class DescendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new DescendingSubMapEntryIterator(absHighest(), absLowFence()); &#125; &#125; // 返回“降序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new DescendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absLower(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absHigher(key); &#125; &#125; // SubMap是旧版本的类，新的Java中没有用到。 private class SubMap extends AbstractMap&lt;K,V&gt; implements SortedMap&lt;K,V&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -6520786458950516097L; private boolean fromStart = false, toEnd = false; private K fromKey, toKey; private Object readResolve() &#123; return new AscendingSubMap(TreeMap.this, fromStart, fromKey, true, toEnd, toKey, false); &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; throw new InternalError(); &#125; public K lastKey() &#123; throw new InternalError(); &#125; public K firstKey() &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; headMap(K toKey) &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; throw new InternalError(); &#125; public Comparator&lt;? super K&gt; comparator() &#123; throw new InternalError(); &#125; &#125; // 红黑树的节点颜色--红色 private static final boolean RED = false; // 红黑树的节点颜色--黑色 private static final boolean BLACK = true; // “红黑树的节点”对应的类。 // 包含了 key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色) static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 键 K key; // 值 V value; // 左孩子 Entry&lt;K,V&gt; left = null; // 右孩子 Entry&lt;K,V&gt; right = null; // 父节点 Entry&lt;K,V&gt; parent; // 当前节点颜色 boolean color = BLACK; // 构造函数 Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; // 返回“键” public K getKey() &#123; return key; &#125; // 返回“值” public V getValue() &#123; return value; &#125; // 更新“值”，返回旧的值 public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; // 判断两个节点是否相等的函数，覆盖equals()函数。 // 若两个节点的“key相等”并且“value相等”，则两个节点相等 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; // 覆盖hashCode函数。 public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; &#125; // 覆盖toString()函数。 public String toString() &#123; return key + "=" + value; &#125; &#125; // 返回“红黑树的第一个节点” final Entry&lt;K,V&gt; getFirstEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p; &#125; // 返回“红黑树的最后一个节点” final Entry&lt;K,V&gt; getLastEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.right != null) p = p.right; return p; &#125; // 返回“节点t的后继节点” static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123; Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 返回“节点t的前继节点” static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.left != null) &#123; Entry&lt;K,V&gt; p = t.left; while (p.right != null) p = p.right; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.left) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 返回“节点p的颜色” // 根据“红黑树的特性”可知：空节点颜色是黑色。 private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) &#123; return (p == null ? BLACK : p.color); &#125; // 返回“节点p的父节点” private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) &#123; return (p == null ? null: p.parent); &#125; // 设置“节点p的颜色为c” private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) &#123; if (p != null) p.color = c; &#125; // 设置“节点p的左孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) &#123; return (p == null) ? null: p.left; &#125; // 设置“节点p的右孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) &#123; return (p == null) ? null: p.right; &#125; // 对节点p执行“左旋”操作 private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125; &#125; // 对节点p执行“右旋”操作 private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125; &#125; // 插入之后的修正操作。 // 目的是保证：红黑树插入节点之后，仍然是一颗红黑树 private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; // 删除“红黑树的节点p” private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor (p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; // 删除之后的修正操作。 // 目的是保证：红黑树删除节点之后，仍然是一颗红黑树 private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK); &#125; private static final long serialVersionUID = 919286545866124006L; // java.io.Serializable的写入函数 // 将TreeMap的“容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeMap的“容量、所有的Entry”依次读出 private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Read in size int size = s.readInt(); buildFromSorted(size, null, s, null); &#125; // 根据已经一个排好序的map创建一个TreeMap private void buildFromSorted(int size, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; this.size = size; root = buildFromSorted(0, 0, size-1, computeRedLevel(size), it, str, defaultVal); &#125; // 根据已经一个排好序的map创建一个TreeMap // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。 private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi, int redLevel, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; if (hi &lt; lo) return null; // 获取中间元素 int mid = (lo + hi) / 2; Entry&lt;K,V&gt; left = null; // 若lo小于mid，则递归调用获取(middel的)左孩子。 if (lo &lt; mid) left = buildFromSorted(level+1, lo, mid - 1, redLevel, it, str, defaultVal); // 获取middle节点对应的key和value K key; V value; if (it != null) &#123; if (defaultVal==null) &#123; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next(); key = entry.getKey(); value = entry.getValue(); &#125; else &#123; key = (K)it.next(); value = defaultVal; &#125; &#125; else &#123; // use stream key = (K) str.readObject(); value = (defaultVal != null ? defaultVal : (V) str.readObject()); &#125; // 创建middle节点 Entry&lt;K,V&gt; middle = new Entry&lt;K,V&gt;(key, value, null); // 若当前节点的深度=红色节点的深度，则将节点着色为红色。 if (level == redLevel) middle.color = RED; // 设置middle为left的父亲，left为middle的左孩子 if (left != null) &#123; middle.left = left; left.parent = middle; &#125; if (mid &lt; hi) &#123; // 递归调用获取(middel的)右孩子。 Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel, it, str, defaultVal); // 设置middle为left的父亲，left为middle的左孩子 middle.right = right; right.parent = middle; &#125; return middle; &#125; // 计算节点树为sz的最大深度，也是红色节点的深度值。 private static int computeRedLevel(int sz) &#123; int level = 0; for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1) level++; return level; &#125;&#125;]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-集合框架(1)]]></title>
    <url>%2F2019%2F07%2F26%2Fjava%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[集合简介java中集合是开发中必不可少的常用利器，而在很多面试过程中，集合框架的内部实现原理也是面试中的重点。我们先看一下集合框架的框架结构图，熟悉一下基本的脉络。下面这张张图是我从网上博客摘取的，在此谢谢你精心的绘制。说明一下颜色含义：黄色：代表接口 绿色：代表抽象接口 蓝色：代表实现类 java中集合框架的总图这是两个集合框架接口的总体图分为两个集合接口，分别是Collection接口，和map接口，collection集合是单列集合，而map集合是双列集合，下面我们将详细的从简单的功能功能学习到它的底层实现原理的探索。 Collection集合接口说起存储数据，我们第一个想到的便是使用变量，数组，但是数组有一定的局限性，它一被创建下来，大小就是固定的了，而集合可以根据需要，自动进行增长。数组只能存储固定的一种类型，而集合却可以存储任意类型。种种的优点让我们选择了集合。 集合框架的出现集合框架在jdk1.1时，只有vector一种集合 1.5后出现了集合框架。 集合的实现接口以及子实现类集合的顶层接口：Collection&lt;E&gt;下面主要的三个接口分别是list set Queue list列表是有序，有下标的，可重复的 除linkhashset之外 set集合是无序的，没有下标，不可重复list的主要实现类是：ArrayList LinkedList vector ArrayList的底层是通过数组实现的LinkedList底层是通过链表实现的vector的底层也是通过数组实现 其中和ArrayList相比 线程的安全性不同，vector是线程安全的,在vector的大多数方法都使用synchronized关键字修饰，arrayList是线程不安全的（可以通过Collections.synchronizedList（）实现线程安全） 性能上的差别，由于vector的方法都有同步锁，在方法执行时需要加锁、解锁，所以在执行过程中效率会低于ArrayList，另外，性能上的差别还体现在底层的Object数组上。 默认都是创建容量为10的数组,但ArrayList自动扩容为原来的1.5倍，vector则扩容为原来的两倍123456789101112131415161718192021//扩容，传入最小容量，跟 ArrayList.grow(int) 很相似，只是扩大量不同 private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //如果增长量 capacityIncrement 不大于 0 ，就扩容 2 倍 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 扩容操作在添加元素时触发。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-面向对象]]></title>
    <url>%2F2019%2F07%2F26%2Fjava%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Java面向对象概述和三大特性 Java 是面向对象的高级编程语言，类和对象是 Java 程序的构成核心。围绕着 Java 类和 Java 对象，有三大基本特性：封装是 Java 类的编写规范、继承是类与类之间联系的一种形式、而多态为系统组件或模块之间解耦提供了解决方案。 本文主要围绕这三大特性介绍一下 Java 面向对象、组件解耦的核心思想。1、面向对象思想 面向对象编程是当今主流的程序设计思想，已经取代了过程化程序开发技术，Java 是完全面向对象编程语言，所以必须熟悉面向对象才能够编写 Java 程序。 面向对象的程序核心是由对象组成的，每个对象包含着对用户公开的特定功能和隐藏的实现部分。程序中的很多对象来自 JDK 标准库，而更多的类需要我们程序员自定义。 从理论上讲，只要对象能够实现业务功能，其具体的实现细节不必特别关心。 面向对象有以下特点： （1）面向对象是一种常见的思想，比较符合人们的思考习惯； （2）面向对象可以将复杂的业务逻辑简单化，增强代码复用性； （3）面向对象具有抽象、封装、继承、多态等特性。 面向对象的编程语言主要有：C++、Java、C#等。2、类和对象的关系 类： 对某类事物的普遍一致性特征、功能的抽象、描述和封装，是构造对象的模版或蓝图，用 Java 编写的代码都会在某些类的内部。类之间主要有：依赖、聚合、继承等关系。 对象： 使用 new 关键字或反射技术创建的某个类的实例。同一个类的所有对象，都具有相似的数据（比如人的年龄、性别）和行为（比如人的吃饭、睡觉），但是每个对象都保存着自己独特的状态，对象状态会随着程序的运行而发生改变，需要注意状态的变化必须通过调用方法来改变，这就是封装的基本原则。3、封装思想 核心思想就是“隐藏细节”、“数据安全”：将对象不需要让外界访问的成员变量和方法私有化，只提供符合开发者意愿的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。 具体的实现方式就是： 使用 private 修饰符把成员变量设置为私有，防止外部程序直接随意调用或修改成员变量，然后对外提供 public 的 set 和 get 方法按照开发者的意愿（可以编写一些业务逻辑代码，虽然很少这样做）设置和获取成员变量的值。 也可以把只在本类内部使用的方法使用 private，这就是封装的思想，是面向对象最基本的开发规范之一。 在此，我们有必要说一下 Java 的访问权限修饰关键字。Java 中主要有 private、protected、public 和 默认访问权限 四种： public 修饰符，具有最大的访问权限，可以访问任何一个在 CLASSPATH 下的类、接口、异常等。 protected 修饰符，主要作用就是用来保护子类，子类可以访问这些成员变量和方法，其余类不可以。 default 修饰符，主要是本包的类可以访问。 private 修饰符，访问权限仅限于本类内部，在实际开发过程中，大多数的成员变量和方法都是使用 private 修饰的。 Java 的访问控制是停留在编译层的，只在编译时进行访问权限检查，不会在类文件中留下痕迹。 通过反射机制，还是可以访问类的私有成员的。 在实际的开发过程中，这样的封装方式已经成了 Java Bean 代码编写的规范。现在主流的框架在使用反射技术为对象赋值、取值时使用的都是 set 和 get 方法，而不是直接操作字段的值。 4、继承和类实例化过程 （1）在多个不同的类中抽取出共性的数据和逻辑，对这些共性的内容进行封装一个新的类即父类（也叫做超类或基类），让之前的类来继承这个类，那些共性的内容在子类中就不必重复定义，比如 BaseDAO、BaseAction 等。 （2）Java 的继承机制是单继承，即一个类只能有一个直接父类。 （3）如果子类和父类有同名成员变量和方法，子类可以使用 super 关键字调用父类的成员变量和方法，上述使用方式前提是成员在子类可见。 （4）在调用子类构造方法时，会隐式的调用父类的构造方法 super()。如果父类没有无参构造方法，为了避免编译错误，需要在子类构造方法中显式的调用父类的含参构造方法。 （5）子类创建时调用父类构造方法：子类需要使用父类的成员变量和方法，所以就要调用父类构造方法来初始化，之后再进行子类成员变量和方法的初始化。因此，构造方法是无法覆盖的。 （6）当子类需要扩展父类的某个方法时，可以覆盖父类方法，但是子类方法访问权限必须大于或等于父类权限。 （7）继承提高了程序的复用性、扩展性，也是 Java 语言多态特征的前提。 （8）在实际开发、程序设计过程中，并非先有的父类，而是先有了子类中通用的数据和逻辑，然后再抽取封装出来的父类。 我们简单了解下类的实例化过程 （1）JVM 读取指定 classpath 路径下的 class 文件，加载到内存，如果有直接父类，也会加载父类； （2）堆内存分配空间； （3）执行父类、子类静态代码块； （4）对象属性进行默认初始化； （5）调用构造方法； （6）在构造方法中，先调用父类构造方法初始化父类数据； （7）初始化父类数据后，显示初始化，执行子类的构造代码块； （8）再进行子类构造方法的特定初始化； （9）初始化完毕后，将地址赋值给引用 为了说明上面的内容，我们来编写一个简单的例子，实际意义并不大，只是为了演示类继承实例化的过程。 5、多态、反射和组件解耦 多态指允许不同类的对象对同一“消息”做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。可以用于消除类型之间的耦合关系，Spring 的核心就是多态和面向接口编程。 （1）Java 中可以使用父类、接口变量引用子类、实现类对象； （2）在这个过程中，会对子类、实现类对象做自动类型提升，其特有功能就无法访问了，如果需要使用，可以做强制类型转换。 Java 的反射技术和多态特性是框架开发、组件解耦的核心，在这方面，Spring 的 IOC 和 DI 为我们提供了一个极好的学习范例，Spring 的 IOC 使用反射技术创建、管理对象，DI 使用多态技术为组件注入依赖对象。 在没有学习 Spring 之前，简单的解决方案是使用一个 .properties 文件保存程序中使用的接口、实现类类型键值信息，然后在程序中使用一个全局 Properties 对象保存这些信息，并且使用反射技术把这些实现类初始化、提供一个静态的方法获取指定接口的实现类对象，在组件中就可以使用依赖对象的键获取需要的对象。 这样的方案带来的好处就是：当我们需要修改某个组件的实现方式时，比如把之前 JDBC 的 DAO 实现改为 Hibernate 实现，只要把这些新的实现类放到 classpath 下，把 .properties 文件对应接口的实现类类型改成新的 Hibernate 实现类，而不需要修改依赖组件的代码。]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2019%2F07%2F24%2Fjava%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java的特性 1.简单性Java看起来设计得很像C++，但是为了使语言小和容易熟悉，设计者们把C++语言中许多可用的特征去掉了，这些特征是一般程序员很少使用的。例如，Java不支持go to语句，代之以提供break和continue语句以及异常处理。Java还剔除了C++的操作符过载（overload）和多继承特征，并且不使用主文件，免去了预处理程序。因为Java没有结构，数组和串都是对象，所以不需要指针。Java能够自动处理对象的引用和间接引用，实现自动的无用单元收集，使用户不必为存储管理问题烦恼，能更多的时间和精力花在研发上。 2.面向对象Java是一个面向对象的语言。对程序员来说，这意味着要注意应中的数据和操纵数据的方法（method），而不是严格地用过程来思考。在一个面向对象的系统中，类（class）是数据和操作数据的方法的集合。数据和方法一起描述对象（object）的状态和行为。每一对象是其状态和行为的封装。类是按一定体系和层次安排的，使得子类可以从超类继承行为。在这个类层次体系中有一个根类，它是具有一般行为的类。Java程序是用类来组织的。Java还包括一个类的扩展集合，分别组成各种程序包（Package），用户可以在自己的程序中使用。例如，Java提供产生图形用户接口部件的类（java.awt包），这里awt是抽象窗口工具集（abstract windowing toolkit）的缩写，处理输入输出的类（java.io包）和支持网络功能的类（java.net包）。 3.分布性Java设计成支持在网络上应用，它是分布式语言。Java既支持各种层次的网络连接，又以Socket类支持可靠的流（stream）网络连接，所以用户可以产生分布式的客户机和服务器。网络变成软件应用的分布运载工具。Java程序只要编写一次，就可到处运行。 4.编译和解释性Java编译程序生成字节码（byte-code），而不是通常的机器码。Java字节码提供对体系结构中性的目标文件格式，代码设计成可有效地传送程序到多个平台。Java程序可以在任何实现了Java解释程序和运行系统（run-time system）的系统上运行。在一个解释性的环境中，程序开发的标准“链接”阶段大大消失了。如果说Java还有一个链接阶段，它只是把新类装进环境的过程，它是增量式的、轻量级的过程。因此，Java支持快速原型和容易试验，它将导致快速程序开发。这是一个与传统的、耗时的“编译、链接和测试”形成鲜明对比的精巧的开发过程。 5.稳健性Java原来是用作编写消费类家用电子产品软件的语言，所以它是被设计成写高可靠和稳健软件的。Java消除了某些编程错误，使得用它写可靠软件相当容易。Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。可靠性方面最重要的增强之一是Java的存储模型。Java不支持指针，它消除重写存储和讹误数据的可能性。类似地，Java自动的“无用单元收集”预防存储漏泄和其它有关动态存储分配和解除分配的有害错误。Java解释程序也执行许多运行时的检查，诸如验证所有数组和串访问是否在界限之内。异常处理是Java中使得程序更稳健的另一个特征。异常是某种类似于错误的异常条件出现的信号。使用try/catch/finally语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。 6.安全性Java的存储分配模型是它防御恶意代码的主要方法之一。Java没有指针，所以程序员不能得到隐蔽起来的内幕和伪造指针去指向存储器。更重要的是，Java编译程序不处理存储安排决策，所以程序员不能通过查看声明去猜测类的实际存储安排。编译的Java代码中的存储引用在运行时由Java解释程序决定实际存储地址。Java运行系统使用字节码验证过程来保证装载到网络上的代码不违背任何Java语言限制。这个安全机制部分包括类如何从网上装载。例如，装载的类是放在分开的名字空间而不是局部类，预防恶意的小应用程序用它自己的版本来代替标准Java类。 7.可移植性Java使得语言声明不依赖于实现的方面。例如，Java显式说明每个基本数据类型的大小和它的运算行为（这些数据类型由Java语法描述）。Java环境本身对新的硬件平台和操作系统是可移植的。Java编译程序也用Java编写，而Java运行系统用ANSIC语言编写。 8.高性能Java是一种先编译后解释的语言，所以它不如全编译性语言快。但是有些情况下性能是很要紧的，为了支持这些情况，Java设计者制作了“及时”编译程序，它能在运行时把Java字节码翻译成特定CPU（中央处理器）的机器代码，也就是实现全编译了。Java字节码格式设计时考虑到这些“及时”编译程序的需要，所以生成机器代码的过程相当简单，它能产生相当好的代码。 9.多线索性Java是多线索语言，它提供支持多线索的执行（也称为轻便过程），能处理不同任务，使具有线索的程序设计很容易。Java的lang包提供一个Thread类，它支持开始线索、运行线索、停止线索和检查线索状态的方法。 Java的线索支持也包括一组同步原语。这些原语是基于监督程序和条件变量风范，由C.A.R.Haore开发的广泛使用的同步化方案。用关键词synchronized，程序员可以说明某些方法在一个类中不能并发地运行。这些方法在监督程序控制之下，确保变量维持在一个一致的状态。 10.动态性Java语言设计成适应于变化的环境，它是一个动态的语言。例如，Java中的类是根据需要载入的，甚至有些是通过网络获取的。java的基本数据类型 byte 比特 1个字节 short 短整型 2个字节 int 整型 4个字节 long 长整型 8个字节 char 字符型 1个字节（根据编码规则） float 单精度浮点型 4个字节 double 双精度浮点型 8个字节 boolean 布尔型 1个字节java的引用数据类型 object 对象类型 [] 数组类型运算符基本运算符 和C语言基本相同（加减乘除取余）逻辑运算符 与运算 或运算 非运算 （短路）三目运算符 表达式1 ? 表达式2 : 表达式3移位运算符 &lt;&lt; &gt;&gt;左移 又移 流程控制 if 选择分支 if else 多条件分支 switch case 多条件分支 （注意没有break会向下穿透） while 循环 for 循环]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>javaSE</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试页</category>
      </categories>
  </entry>
</search>
